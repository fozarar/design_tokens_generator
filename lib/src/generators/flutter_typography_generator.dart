import 'flutter_color_generator.dart';

class FlutterTypographyGenerator implements CodeGenerator {
  @override
  String generate(
      Map<String, dynamic> resolvedTokens, Map<String, String> tokenTypes) {
    final buffer = StringBuffer();

    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln();
    buffer.writeln('/// Auto-generated design tokens for typography');
    buffer.writeln('/// Do not edit this file manually');
    buffer.writeln('class AppTypography {');

    // Group typography tokens by theme and category to avoid duplicates
    final themeGroups =
        <String, Map<String, List<MapEntry<String, dynamic>>>>{};
    final processedTokens = <String>{};

    for (final entry in resolvedTokens.entries) {
      if (entry.key.contains('typography') ||
          tokenTypes[entry.key] == 'typography') {
        final parts = entry.key.split('.');
        final themeName = parts.length > 1 ? parts[1] : 'base';
        final category = parts.length > 2 ? parts[2] : 'typography';

        final tokenName = _generateTokenName(entry.key);

        // Skip if already processed (avoid duplicates)
        if (processedTokens.contains(tokenName)) {
          continue;
        }
        processedTokens.add(tokenName);

        themeGroups.putIfAbsent(themeName, () => {});
        themeGroups[themeName]!.putIfAbsent(category, () => []).add(entry);
      }
    }

    // Generate TextStyle constants grouped by theme and category
    for (final theme in themeGroups.entries) {
      final themeName = _capitalize(theme.key);

      buffer.writeln();
      buffer.writeln('  // $themeName Typography');

      for (final category in theme.value.entries) {
        for (final token in category.value) {
          final tokenName = _generateTokenName(token.key);
          final textStyle = _generateTextStyle(token.value);
          buffer.writeln(
              '  static const TextStyle $tokenName = TextStyle($textStyle);');
        }
      }
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  String _generateTokenName(String path) {
    final parts = path
        .split('.')
        .skip(1) // Skip the first part
        .map((part) => part.replaceAll(RegExp(r'[^a-zA-Z0-9]'), ''))
        .where((part) => part.isNotEmpty)
        .toList();

    if (parts.isEmpty) return 'defaultStyle';

    // Convert to lowerCamelCase
    final result = StringBuffer(parts.first.toLowerCase());
    for (int i = 1; i < parts.length; i++) {
      final part = parts[i];
      if (part.isNotEmpty) {
        result.write(part[0].toUpperCase() + part.substring(1).toLowerCase());
      }
    }

    return result.toString();
  }

  String _capitalize(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  String _generateTextStyle(dynamic typography) {
    final properties = <String>[];

    if (typography is Map<String, dynamic>) {
      if (typography.containsKey('fontSize')) {
        properties.add('fontSize: ${typography['fontSize']}');
      }
      if (typography.containsKey('fontWeight')) {
        final weight = _parseFontWeight(typography['fontWeight']);
        properties.add('fontWeight: $weight');
      }
      if (typography.containsKey('lineHeight')) {
        properties.add('height: ${typography['lineHeight']}');
      }
      if (typography.containsKey('letterSpacing')) {
        properties.add('letterSpacing: ${typography['letterSpacing']}');
      }
      if (typography.containsKey('fontFamily')) {
        properties.add("fontFamily: '${typography['fontFamily']}'");
      }
    }

    return properties.join(', ');
  }

  String _parseFontWeight(dynamic weight) {
    if (weight is int || weight is double) {
      switch (weight.toInt()) {
        case 100:
          return 'FontWeight.w100';
        case 200:
          return 'FontWeight.w200';
        case 300:
          return 'FontWeight.w300';
        case 400:
          return 'FontWeight.w400';
        case 500:
          return 'FontWeight.w500';
        case 600:
          return 'FontWeight.w600';
        case 700:
          return 'FontWeight.w700';
        case 800:
          return 'FontWeight.w800';
        case 900:
          return 'FontWeight.w900';
      }
    }

    if (weight is String) {
      switch (weight.toLowerCase()) {
        case 'normal':
        case 'regular':
          return 'FontWeight.normal';
        case 'bold':
          return 'FontWeight.bold';
        case 'light':
          return 'FontWeight.w300';
        case 'medium':
          return 'FontWeight.w500';
        case 'semibold':
          return 'FontWeight.w600';
      }
    }

    return 'FontWeight.normal';
  }
}
