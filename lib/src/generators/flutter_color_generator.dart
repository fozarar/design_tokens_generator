abstract class CodeGenerator {
  String generate(
      Map<String, dynamic> resolvedTokens, Map<String, String> tokenTypes);
}

class FlutterColorGenerator implements CodeGenerator {
  @override
  String generate(
      Map<String, dynamic> resolvedTokens, Map<String, String> tokenTypes) {
    final buffer = StringBuffer();

    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln();
    buffer.writeln("/// Auto-generated design tokens for colors");
    buffer.writeln("/// Do not edit this file manually");
    buffer.writeln("class AppColors {");

    // Group tokens by theme first, then by category
    final themeGroups =
        <String, Map<String, List<MapEntry<String, dynamic>>>>{};
    final individualColors = <MapEntry<String, dynamic>>[];

    for (final entry in resolvedTokens.entries) {
      if (tokenTypes[entry.key] == 'color') {
        final parts = entry.key.split('.');

        // Check if it's a themed color or individual color
        if (parts.length >= 3 &&
            (parts[1] == 'color' || parts[1] == 'colors')) {
          // This is likely an individual color, add it to individual colors
          individualColors.add(entry);
        } else {
          // This might be a themed color or other category
          final themeName = parts.length > 1 ? parts[1] : 'misc';
          final category = parts.length > 2 ? parts[2] : 'colors';

          themeGroups.putIfAbsent(themeName, () => {});
          themeGroups[themeName]!.putIfAbsent(category, () => []).add(entry);
        }
      }
    }

    // Generate individual colors first (these are common/value colors)
    if (individualColors.isNotEmpty) {
      buffer.writeln();
      buffer.writeln("  // Value Colors");

      // Use Set to track already added color names to prevent duplicates
      final addedColors = <String>{};

      for (final token in individualColors) {
        final tokenName = _generateTokenName(token.key);
        if (!addedColors.contains(tokenName)) {
          addedColors.add(tokenName);
          final colorValue = _parseColor(token.value);
          buffer
              .writeln("  static const Color $tokenName = Color($colorValue);");
        }
      }
    }

    // Generate themed colors with separate sections
    for (final theme in themeGroups.entries) {
      final themeName = _capitalize(theme.key);

      // Skip if this looks like a duplicate theme
      if (themeName.toLowerCase() == 'color' ||
          themeName.toLowerCase() == 'colors') {
        continue;
      }

      buffer.writeln();
      buffer.writeln("  // $themeName Theme Colors");

      final addedThemeColors = <String>{};

      for (final category in theme.value.entries) {
        for (final token in category.value) {
          final tokenName =
              _generateThemeTokenName(token.key, themeName.toLowerCase());
          if (!addedThemeColors.contains(tokenName)) {
            addedThemeColors.add(tokenName);
            final colorValue = _parseColor(token.value);
            buffer.writeln(
                "  static const Color $tokenName = Color($colorValue);");
          }
        }
      }
    }

    buffer.writeln("}");

    return buffer.toString();
  }

  String _generateTokenName(String path) {
    return path
        .split('.')
        .skip(1) // Skip the first part
        .map((part) => part.replaceAll(RegExp(r'[^a-zA-Z0-9]'), ''))
        .map((part) => part.toLowerCase())
        .join('_')
        .replaceAll('__', '_');
  }

  String _generateThemeTokenName(String path, String theme) {
    final baseName = path
        .split('.')
        .skip(1) // Skip the first part
        .map((part) => part.replaceAll(RegExp(r'[^a-zA-Z0-9]'), ''))
        .map((part) => part.toLowerCase())
        .join('_')
        .replaceAll('__', '_');

    return '${theme}_$baseName';
  }

  String _capitalize(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  String _parseColor(dynamic colorValue) {
    if (colorValue is String) {
      String hex = colorValue.replaceAll('#', '');

      // Handle 8-digit hex (with alpha)
      if (hex.length == 8) {
        return '0x$hex';
      }
      // Handle 6-digit hex (without alpha)
      else if (hex.length == 6) {
        return '0xFF$hex';
      }
      // Handle 3-digit hex
      else if (hex.length == 3) {
        final r = hex[0];
        final g = hex[1];
        final b = hex[2];
        return '0xFF$r$r$g$g$b$b';
      }
    }

    // Fallback
    return '0xFF000000';
  }
}
