// ignore_for_file: avoid_print

import 'dart:io';
import 'loaders/token_loader.dart';
import 'resolvers/token_resolver.dart';
import 'generators/flutter_color_generator.dart';
import 'generators/flutter_spacing_generator.dart';
import 'generators/flutter_typography_generator.dart';

class DesignTokenGenerator {
  final String assetsPath;
  final String outputPath;

  DesignTokenGenerator({
    required this.assetsPath,
    required this.outputPath,
  });

  /// Generate all design token files
  Future<void> generate() async {
    print('üé® Starting design token generation...');

    // Load tokens
    print('üìÇ Loading design tokens from $assetsPath');
    final loader = TokenLoader(assetsPath: assetsPath);
    final tokenSets = await loader.loadAllTokens();

    // Flatten tokens
    print('üîß Processing tokens...');
    final flattenedTokens = loader.flattenTokens(tokenSets);

    // Create token types map for generators
    final tokenTypes = <String, String>{};
    for (final entry in flattenedTokens.entries) {
      tokenTypes[entry.key] = entry.value.type;
    }

    // Resolve token references
    print('üîó Resolving token references...');
    final resolver = TokenResolver(flattenedTokens);
    final resolvedTokens = resolver.resolveAllTokens();

    // Ensure output directory exists
    final outputDir = Directory(outputPath);
    if (!await outputDir.exists()) {
      await outputDir.create(recursive: true);
    }

    // Generate color tokens
    await _generateColorTokens(resolvedTokens, tokenTypes);

    // Generate spacing tokens
    await _generateSpacingTokens(resolvedTokens, tokenTypes);

    // Generate typography tokens
    await _generateTypographyTokens(resolvedTokens, tokenTypes);

    // Generate main theme file
    await _generateMainThemeFile(resolvedTokens);

    print('‚úÖ Design token generation completed successfully!');
    print('üìÅ Generated files in: $outputPath');
  }

  Future<void> _generateColorTokens(Map<String, dynamic> resolvedTokens,
      Map<String, String> tokenTypes) async {
    print('üé® Generating color tokens...');
    final generator = FlutterColorGenerator();
    final code = generator.generate(resolvedTokens, tokenTypes);

    final file = File('$outputPath/app_colors.dart');
    await file.writeAsString(code);
    print('   ‚úì Generated app_colors.dart');
  }

  Future<void> _generateSpacingTokens(Map<String, dynamic> resolvedTokens,
      Map<String, String> tokenTypes) async {
    print('üìè Generating spacing tokens...');
    final generator = FlutterSpacingGenerator();
    final code = generator.generate(resolvedTokens, tokenTypes);

    final file = File('$outputPath/app_spacing.dart');
    await file.writeAsString(code);
    print('   ‚úì Generated app_spacing.dart');
  }

  Future<void> _generateTypographyTokens(Map<String, dynamic> resolvedTokens,
      Map<String, String> tokenTypes) async {
    print('üî§ Generating typography tokens...');
    final generator = FlutterTypographyGenerator();
    final code = generator.generate(resolvedTokens, tokenTypes);

    final file = File('$outputPath/app_typography.dart');
    await file.writeAsString(code);
    print('   ‚úì Generated app_typography.dart');
  }

  Future<void> _generateMainThemeFile(
      Map<String, dynamic> resolvedTokens) async {
    print('üé≠ Generating main theme file...');
    final buffer = StringBuffer();

    // Otomatik olarak uygun seed renklerini bul
    final seedColors = _findBestSeedColors(resolvedTokens);

    // Button renklerini bul
    final buttonColors = _findButtonColors(resolvedTokens);

    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import 'app_colors.dart';");
    buffer.writeln();
    buffer.writeln("/// Auto-generated design system theme");
    buffer.writeln("/// Do not edit this file manually");
    buffer.writeln("class AppTheme {");
    buffer.writeln("  static ThemeData get lightTheme {");
    buffer.writeln("    return ThemeData(");
    buffer.writeln("      useMaterial3: true,");
    buffer.writeln("      colorScheme: ColorScheme.fromSeed(");
    buffer.writeln("        seedColor: ${seedColors['light']},");
    buffer.writeln("        brightness: Brightness.light,");
    buffer.writeln("      ),");

    // Button theme'ini ekle eƒüer button renkleri varsa
    if (buttonColors.isNotEmpty) {
      buffer.writeln("      elevatedButtonTheme: ElevatedButtonThemeData(");
      buffer.writeln("        style: ElevatedButton.styleFrom(");
      if (buttonColors['elevated'] != null) {
        buffer
            .writeln("          backgroundColor: ${buttonColors['elevated']},");
        buffer.writeln("          foregroundColor: Colors.white,");
      }
      buffer.writeln("        ),");
      buffer.writeln("      ),");

      if (buttonColors['primary'] != null) {
        buffer.writeln("      filledButtonTheme: FilledButtonThemeData(");
        buffer.writeln("        style: FilledButton.styleFrom(");
        buffer
            .writeln("          backgroundColor: ${buttonColors['primary']},");
        buffer.writeln("          foregroundColor: Colors.white,");
        buffer.writeln("        ),");
        buffer.writeln("      ),");
      }
    }

    buffer.writeln("      textTheme: TextTheme(");
    buffer.writeln(
        "        displayLarge: _createTextStyle(32, FontWeight.w800, 40),");
    buffer.writeln(
        "        displayMedium: _createTextStyle(30, FontWeight.w700, 38),");
    buffer.writeln(
        "        displaySmall: _createTextStyle(28, FontWeight.w600, 36),");
    buffer.writeln(
        "        headlineLarge: _createTextStyle(24, FontWeight.w600, 32),");
    buffer.writeln(
        "        headlineMedium: _createTextStyle(22, FontWeight.w600, 28),");
    buffer.writeln(
        "        headlineSmall: _createTextStyle(20, FontWeight.w600, 28),");
    buffer.writeln(
        "        titleLarge: _createTextStyle(18, FontWeight.w600, 28),");
    buffer.writeln(
        "        titleMedium: _createTextStyle(16, FontWeight.w500, 24),");
    buffer.writeln(
        "        bodyLarge: _createTextStyle(16, FontWeight.w400, 24),");
    buffer.writeln(
        "        bodyMedium: _createTextStyle(14, FontWeight.w400, 20),");
    buffer.writeln(
        "        bodySmall: _createTextStyle(12, FontWeight.w400, 18),");
    buffer.writeln("      ),");
    buffer.writeln("    );");
    buffer.writeln("  }");
    buffer.writeln();
    buffer.writeln("  static ThemeData get darkTheme {");
    buffer.writeln("    return ThemeData(");
    buffer.writeln("      useMaterial3: true,");
    buffer.writeln("      colorScheme: ColorScheme.fromSeed(");
    buffer.writeln("        seedColor: ${seedColors['dark']},");
    buffer.writeln("        brightness: Brightness.dark,");
    buffer.writeln("      ),");

    // Dark theme i√ßin de button theme'ini ekle
    if (buttonColors.isNotEmpty) {
      buffer.writeln("      elevatedButtonTheme: ElevatedButtonThemeData(");
      buffer.writeln("        style: ElevatedButton.styleFrom(");
      if (buttonColors['elevated'] != null) {
        buffer
            .writeln("          backgroundColor: ${buttonColors['elevated']},");
        buffer.writeln("          foregroundColor: Colors.white,");
      }
      buffer.writeln("        ),");
      buffer.writeln("      ),");

      if (buttonColors['primary'] != null) {
        buffer.writeln("      filledButtonTheme: FilledButtonThemeData(");
        buffer.writeln("        style: FilledButton.styleFrom(");
        buffer
            .writeln("          backgroundColor: ${buttonColors['primary']},");
        buffer.writeln("          foregroundColor: Colors.white,");
        buffer.writeln("        ),");
        buffer.writeln("      ),");
      }
    }

    buffer.writeln("      textTheme: TextTheme(");
    buffer.writeln(
        "        displayLarge: _createTextStyle(32, FontWeight.w800, 40),");
    buffer.writeln(
        "        displayMedium: _createTextStyle(30, FontWeight.w700, 38),");
    buffer.writeln(
        "        displaySmall: _createTextStyle(28, FontWeight.w600, 36),");
    buffer.writeln(
        "        headlineLarge: _createTextStyle(24, FontWeight.w600, 32),");
    buffer.writeln(
        "        headlineMedium: _createTextStyle(22, FontWeight.w600, 28),");
    buffer.writeln(
        "        headlineSmall: _createTextStyle(20, FontWeight.w600, 28),");
    buffer.writeln(
        "        titleLarge: _createTextStyle(18, FontWeight.w600, 28),");
    buffer.writeln(
        "        titleMedium: _createTextStyle(16, FontWeight.w500, 24),");
    buffer.writeln(
        "        bodyLarge: _createTextStyle(16, FontWeight.w400, 24),");
    buffer.writeln(
        "        bodyMedium: _createTextStyle(14, FontWeight.w400, 20),");
    buffer.writeln(
        "        bodySmall: _createTextStyle(12, FontWeight.w400, 18),");
    buffer.writeln("      ),");
    buffer.writeln("    );");
    buffer.writeln("  }");
    buffer.writeln();
    buffer.writeln(
        "  static TextStyle _createTextStyle(double fontSize, FontWeight fontWeight, double height) {");
    buffer.writeln("    return TextStyle(");
    buffer.writeln("      fontSize: fontSize,");
    buffer.writeln("      fontWeight: fontWeight,");
    buffer.writeln("      height: height / fontSize,");
    buffer.writeln("    );");
    buffer.writeln("  }");
    buffer.writeln("}");

    final file = File('$outputPath/app_theme.dart');
    await file.writeAsString(buffer.toString());
    print('   ‚úì Generated app_theme.dart');
  }

  /// Otomatik olarak en uygun seed renklerini bulur
  Map<String, String> _findBestSeedColors(Map<String, dynamic> resolvedTokens) {
    final colorKeys = resolvedTokens.keys
        .where((key) =>
            resolvedTokens[key] is String &&
            (resolvedTokens[key] as String).startsWith('#'))
        .toList();

    print('üîç Found ${colorKeys.length} color tokens:');
    for (int i = 0; i < colorKeys.length && i < 20; i++) {
      print('   ${i + 1}. ${colorKeys[i]} -> ${resolvedTokens[colorKeys[i]]}');
    }
    if (colorKeys.length > 20) {
      print('   ... and ${colorKeys.length - 20} more');
    }

    // Brand token'larƒ±nƒ± √∂zellikle ara
    final brandTokens =
        colorKeys.where((key) => key.toLowerCase().contains('brand')).toList();
    print('üéØ Brand tokens found: ${brandTokens.length}');
    for (final token in brandTokens) {
      print('   Brand: $token -> ${resolvedTokens[token]}');
    }

    // √ñncelik sƒ±rasƒ±: brand -> primary -> blue -> green -> purple -> diƒüerleri
    final priorities = [
      'brand',
      'primary',
      'blue',
      'green',
      'purple',
      'indigo',
      'teal',
      'cyan'
    ];

    String? lightSeed;
    String? darkSeed;

    print('üéØ Searching for seed colors...');

    // Her √∂ncelik i√ßin uygun renkleri ara
    for (final priority in priorities) {
      print('   üîç Looking for "$priority" colors...');

      // Light tema i√ßin 500-600 arasƒ± tonlar
      final lightCandidates = colorKeys
          .where((key) =>
              key.toLowerCase().contains(priority) &&
              (key.contains('500') || key.contains('600')))
          .toList();

      // Dark tema i√ßin 700-800 arasƒ± tonlar
      final darkCandidates = colorKeys
          .where((key) =>
              key.toLowerCase().contains(priority) &&
              (key.contains('700') || key.contains('800')))
          .toList();

      print('     Light candidates: ${lightCandidates.take(3).toList()}');
      print('     Dark candidates: ${darkCandidates.take(3).toList()}');

      if (lightCandidates.isNotEmpty && lightSeed == null) {
        final tokenKey = lightCandidates.first;
        print('     üéØ Selected light token: $tokenKey');
        final colorName = _tokenKeyToColorName(tokenKey);
        lightSeed = 'AppColors.$colorName';
        print('     üéØ Converted to: $lightSeed');
      }

      if (darkCandidates.isNotEmpty && darkSeed == null) {
        final tokenKey = darkCandidates.first;
        print('     üéØ Selected dark token: $tokenKey');
        final colorName = _tokenKeyToColorName(tokenKey);
        darkSeed = 'AppColors.$colorName';
        print('     üéØ Converted to: $darkSeed');
      }

      // Her ikisi de bulunduysa dur
      if (lightSeed != null && darkSeed != null) {
        print('   ‚úÖ Found both seed colors for "$priority"');
        break;
      }
    }

    // Fallback mantƒ±ƒüƒ±...
    if (lightSeed == null && colorKeys.isNotEmpty) {
      print('üîÑ Using fallback for light seed...');
      final fallback = colorKeys.firstWhere(
          (key) => key.contains('500') || key.contains('600'),
          orElse: () => colorKeys.first);
      print('   Fallback token: $fallback');
      final colorName = _tokenKeyToColorName(fallback);
      lightSeed = 'AppColors.$colorName';
    }

    if (darkSeed == null && colorKeys.isNotEmpty) {
      print('üîÑ Using fallback for dark seed...');
      final fallback = colorKeys.firstWhere(
          (key) => key.contains('700') || key.contains('800'),
          orElse: () => colorKeys.first);
      print('   Fallback token: $fallback');
      final colorName = _tokenKeyToColorName(fallback);
      darkSeed = 'AppColors.$colorName';
    }

    print('üé® Final seed color selection:');
    print('   Light: $lightSeed');
    print('   Dark: $darkSeed');

    return {
      'light': lightSeed ?? 'Colors.blue',
      'dark': darkSeed ?? 'Colors.indigo',
    };
  }

  /// Token key'ini AppColors field adƒ±na √ßevirir
  /// FlutterColorGenerator ile tam uyumlu √ßalƒ±≈üacak ≈üekilde d√ºzeltildi
  String _tokenKeyToColorName(String tokenKey) {
    print('   üîß Converting token key: $tokenKey');

    final parts = tokenKey.split('.');
    print('   üìã Parts: $parts');

    // FlutterColorGenerator'ƒ±n aynƒ± mantƒ±ƒüƒ±nƒ± kullan
    // Individual colors i√ßin (Value Colors)
    if (parts.length >= 3 && (parts[1] == 'color' || parts[1] == 'colors')) {
      // Individual color - _generateTokenName mantƒ±ƒüƒ±
      final result = parts
          .skip(1) // ƒ∞lk par√ßayƒ± atla
          .map((part) => part.replaceAll(RegExp(r'[^a-zA-Z0-9]'), ''))
          .map((part) => part.toLowerCase())
          .join('_')
          .replaceAll('__', '_');

      print('   ‚úÖ Individual color result: $result');
      return result;
    } else {
      // Themed color - _generateThemeTokenName mantƒ±ƒüƒ±
      final themeName = parts.length > 1 ? parts[1].toLowerCase() : 'misc';

      final baseName = parts
          .skip(1) // ƒ∞lk par√ßayƒ± atla
          .map((part) => part.replaceAll(RegExp(r'[^a-zA-Z0-9]'), ''))
          .map((part) => part.toLowerCase())
          .join('_')
          .replaceAll('__', '_');

      final result = '${themeName}_$baseName';
      print('   ‚úÖ Themed color result: $result');
      return result;
    }
  }

  /// Button renklerini otomatik olarak bulur
  Map<String, String?> _findButtonColors(Map<String, dynamic> resolvedTokens) {
    final colorKeys = resolvedTokens.keys
        .where((key) =>
            resolvedTokens[key] is String &&
            (resolvedTokens[key] as String).startsWith('#'))
        .toList();

    String? elevatedButtonColor;
    String? primaryButtonColor;

    // Elevated button rengi ara
    final elevatedCandidates = colorKeys
        .where((key) =>
            key.toLowerCase().contains('button') &&
            key.toLowerCase().contains('elevated'))
        .toList();

    if (elevatedCandidates.isNotEmpty) {
      final colorName = _tokenKeyToColorName(elevatedCandidates.first);
      elevatedButtonColor = 'AppColors.$colorName';
    }

    // Primary/normal button rengi ara
    final primaryCandidates = colorKeys
        .where((key) =>
            key.toLowerCase().contains('button') &&
            key.toLowerCase().contains('background') &&
            !key.toLowerCase().contains('elevated'))
        .toList();

    if (primaryCandidates.isNotEmpty) {
      final colorName = _tokenKeyToColorName(primaryCandidates.first);
      primaryButtonColor = 'AppColors.$colorName';
    }

    if (elevatedButtonColor != null || primaryButtonColor != null) {
      print('üî≤ Auto-selected button colors:');
      if (elevatedButtonColor != null)
        print('   Elevated: $elevatedButtonColor');
      if (primaryButtonColor != null) print('   Primary: $primaryButtonColor');
    }

    return {
      'elevated': elevatedButtonColor,
      'primary': primaryButtonColor,
    };
  }
}
